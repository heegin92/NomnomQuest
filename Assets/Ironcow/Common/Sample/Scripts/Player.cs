// ─────────────────────────────────────────────────────────────────────────────
// Part of the Synapse Framework – © 2025 Ironcow Studio
// This file is distributed under the Unity Asset Store EULA:
// https://unity.com/legal/as-terms
// ─────────────────────────────────────────────────────────────────────────────

using Ironcow.Synapse.Core;

using UnityEngine;

namespace Ironcow.Synapse.Sample.Common
{
    public class Player : SynapseBehaviour
#if USE_UPDATABLE
    , IUpdatable
#endif
    {
        #region AutoGenerated
        // This section is auto-generated by AttributeComposer. Do not modify manually.

        [SerializeField]
        private float speed;

        [SerializeField]
        private float jumpPower;

        [SerializeField]
        private Rigidbody rb;

        [SerializeField]
        private float groundCheckDistance;

        [SerializeField]
        private LayerMask groundLayer;

        [SerializeField]
        private BoxCollider col;

        public bool isGrounded;

        #endregion

        private int hp;
        public int Hp => hp;
        private int atk;

        Vector3 moveDirection;

        void Awake()
        {
            hp = 100;
            atk = 5;
        }

        public void OnDamage(int damage)
        {
            hp -= damage;
            if (hp <= 0)
            {
                OnDead();
            }
        }

        public void OnDead()
        {
            this.Release();
        }

#if USE_UPDATABLE
        public void OnUpdate()
#else
    void Update()
#endif
        {
            HandleInput();
            OnMove();
        }

        private void HandleInput()
        {
            moveDirection = new Vector3(Input.GetAxis("Horizontal"), 0, Input.GetAxis("Vertical")).normalized;
            isGrounded = CheckGround();
            if (isGrounded && Input.GetKeyDown(KeyCode.Space))
            {
                rb.AddForce(Vector3.up * jumpPower, ForceMode.VelocityChange);
            }
        }

        private void OnMove()
        {
            if (moveDirection != Vector3.zero)
            {
                var cam = Camera.main.transform;
                Vector3 camF = Vector3.ProjectOnPlane(cam.forward, Vector3.up).normalized;
                Vector3 camR = Vector3.ProjectOnPlane(cam.right, Vector3.up).normalized;

                Vector3 dir = (camF * moveDirection.z + camR * moveDirection.x);
                if (dir.sqrMagnitude > 0.0001f) dir.Normalize();
                rb.MovePosition(rb.position + dir * speed * Time.deltaTime);
                rb.rotation = Quaternion.Slerp(rb.rotation, Quaternion.LookRotation(dir), Time.deltaTime * speed);
            }
        }

        private bool CheckGround()
        {
            Vector3 origin = col.bounds.center + Vector3.down * (col.bounds.extents.y - 0.01f);
            return Physics.Raycast(origin, Vector3.down, groundCheckDistance, groundLayer);
        }

        private void OnCollisionEnter(Collision collision)
        {

            if (collision.TryGetInstance<WorldObject>(out var worldObject))
            {
                var interactionText = worldObject.Interaction();
                Debug.Log(interactionText);
            }
            if (collision.TryGetInstance<Door>(out var door))
            {
                var interactionText = door.Interaction();
                Debug.Log(interactionText);
            }
            if (collision.TryGetInstance<Key>(out var key))
            {
                var interactionText = key.Interaction();
                Debug.Log(interactionText);
            }
            if (collision.TryGetInstance<Enemy>(out var enemy))
            {
                enemy.OnDamage(atk);
            }
        }
    }
}
